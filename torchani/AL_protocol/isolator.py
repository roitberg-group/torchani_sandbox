import torch
import torchani
from torchani.neighbors import FullPairwise
from torchani.tuples import SpeciesCoordinates

import ase
from ase.io import read
import openbabel
from openbabel import pybel
from rdkit import Chem

import numpy as np
from numpy.typing import NDArray
import pandas as pd
import typing as tp
import tempfile
from copy import deepcopy


class Isolator:
    def __init__(self, cutoff: float = 5.2, threshold: float = 0.5):
        # NOTE: Change 'threshold' to 1.0 or higher, 0.5 is just for testing
        self.cutoff = cutoff
        self.threshold = threshold
        
        self.species = None
        self.coordinates = None
        self.structure = None
        self.symbols = None
        
        self.molecule: tp.Optional[Chem.Mol] = None
        self.model = torchani.models.ANIdr().double()

    def read_structure(self, input_file: tp.Optional[str]) -> ase.Atoms:
        """
        Reads molecular structure rom a file using ase.io, returns ase Atoms object.
          File type is guessed by the ase *filetype* function.
          Works well for .xyz and .pdb, unsure about other file types.
        """
        self.input_file = input_file
        return read(self.input_file)

    @classmethod
    def from_file(cls, input_file: str):
        obj = cls()
        obj.structure = obj.read_structure(input_file)
        obj.species = obj.structure.numbers
        obj.coordinates = obj.structure.positions.astype(np.float64)
        obj.symbols = np.asarray(obj.structure.get_chemical_symbols()).astype(str)
        obj.molecule = obj.create_rdkit_mol()
        return obj

    @classmethod
    def from_data(cls, data: SpeciesCoordinates):
        obj = cls()
        obj.species = data[0].squeeze().cpu().numpy()
        obj.coordinates = data[1].squeeze().detach().cpu().numpy()
        obj.structure = ase.Atoms(numbers=obj.species, positions=obj.coordinates)
        obj.symbols = np.asarray(obj.structure.get_chemical_symbols()).astype(str)
        obj.molecule = obj.create_rdkit_mol((obj.symbols, obj.coordinates))
        return obj

    def create_rdkit_mol(self,
        return_smiles: bool = True,
        ) -> Chem.rdchem.Mol:
        """
        This function does the following: 
        * Writes a temp file to read/store xyz information
        * Reads the temp file with openbabel to create a mol2 object (includes connectivity information)
        * Converts the obabel mol2 object into a rdkit.Chem molecule to print the SMILES return the molecule
        """
        with tempfile.NamedTemporaryFile("w+") as f:
            f.write(f"{len(self.symbols)}\n")
            f.write("\n")
            for j, el in enumerate(self.symbols):
                f.write(f"{el} {self.coordinates[j][0]:8.3} {self.coordinates[j][1]:8.3} {self.coordinates[j][2]:8.3}\n")
            f.seek(0)
            obabel_molecule = next(pybel.readfile("xyz", f.name))
            raw_mol2 = obabel_molecule.write(format="mol2")
            molecule = Chem.MolFromMol2Block(raw_mol2, removeHs=False)
            if molecule is None:
                raise RuntimeError("Molecule could not be generated by rdkit")
            if return_smiles:
                print("SMILES: ", Chem.MolToSmiles(Chem.RemoveHs(molecule), isomericSmiles=False))
        return molecule

    def classify_bad_atoms(self):
        """
        Classify the 'bad atoms' (based on the uncertainty threshold set in the class initialization)
        """
        force_qbc = self.model.force_qbc(
            (
            torch.tensor(self.species).unsqueeze(0), 
            torch.tensor(self.coordinates).unsqueeze(0).double()
            )).relative_stdev                                      # NOTE: This doesn't work 

        bad_atom_indices = [1 if i > self.threshold else 0 for i in force_qbc.squeeze()]

        return bad_atom_indices

    def get_neighbors(self, bad_atom_indices):
        """
        Identify neighbors of bad atoms, within the specified cutoff (defaults to 5.2 Angstrom).
        """
        if not any(bad_atom_indices):
            return {}

        species_tensor = torch.tensor(self.species).unsqueeze(0)
        coord_tensor = torch.tensor(self.coordinates, requires_grad=True).unsqueeze(0)

        neighbors = FullPairwise(cutoff=self.cutoff)(
            species_tensor,
            coord_tensor
            )
        neighbor_indices = torch.cat((neighbors.indices, neighbors.indices.flip(0)), dim=-1).transpose(1, 0)
        neighbors_of_bad_atoms = {}

        for bad_atom in bad_atom_indices:
            idxs = neighbor_indices[neighbor_indices[:, 0] == bad_atom, 1]
            neighbors_of_bad_atoms[bad_atom] = idxs.tolist()
        return neighbors_of_bad_atoms

    def cap_atoms(self, bad_atom_indices):
        """
        Cap 'leaf bad atoms' by replacing them with Hydrogen atoms.
        """
        capped_indices = deepcopy(bad_atom_indices)
        _, leaf_bad_atom_indices = self.classify_bad_atoms(bad_atom_indices)

        atom_list = list(self.molecule.GetAtoms())
        bad_atom_set = set(bad_atom_indices)

        for idx in leaf_bad_atom_indices:
            atom = atom_list[idx]
            bonds = atom.GetBonds()
            for bond in bonds:
                begin = bond.GetBeginAtomIdx()
                if begin not in bad_atom_indices:
                    bond_type = bond.GetBondType()
                    if bond_type is not Chem.rdchem.BondType.SINGLE:
                        # NOTE: Placeholder if statement -- must configure for non-single bond types
                        raise NotImplementedError("Not yet implemented.")
                    else:
                        if isinstance(self.symbols, np.ndarray):
                            self.symbols[begin] = "H"
                        elif isinstance(self.symbols, torch.Tensor):    # NOTE: Might need a bit of editing if the tensors aren't nicely organized as GPT suggested they are (i.e., if it is [[1]] rather than [1])
                            self.symbols[begin] = torch.tensor([1], dtype=torch.int)
                        capped_indices.append(begin)
        if isinstance(self.coordinates, torch.Tensor):
            return self.coordinates[capped_indices], self.symbols[capped_indices]
        else:
            return self.coordinates[capped_indices].tolist(), self.symbols[capped_indices].tolist()

    def process_bad_atom(self, atom_index, all_bad_atoms):
        """
        Create a new "capped" structure for each high-uncertainty atom present in the input
        """
        all_neighbors = self.get_neighbors()
        neighbors_of_bad_atoms = set(all_neighbors[atom_index].tolist())
        atoms_to_cap = neighbors_of_bad_atoms - set(all_bad_atoms)
        capped_coords, capped_symbols = self.cap_atoms(atoms_to_cap)
        return ase.Atoms(positions=capped_coords, symbols=capped_symbols)

    def process_molecule(self, bad_atom_indices, output_file_prefix="./capped", output_format='xyz'):
        """
        Go through the molecule and create new structures for each of the "bad atoms"
        """
        # NOTE: Probably update this based on GPT suggestion in "Restructuring and improving ..."
        for idx, bad_atom in enumerate(bad_atom_indices):
            capped_structure = self.process_bad_atom(bad_atom, bad_atom_indices)
            output_file = f"{output_file_prefix}_atom{idx}.{output_format}"
            ase.io.write(output_file, capped_structure)

    def run_the_thing(self, input, is_file=False):
        if is_file:
            instance = self.from_file(input)
        else:
            instance = self.from_data(input)
        
        self.symbols = instance.symbols
        self.coordinates = instance.coordinates
        self.species = instance.species
        self.structure = instance.structure
        
        self.molecule = self.create_rdkit_mol((self.symbols, self.coordinates))

        self.bad_atoms = self.classify_bad_atoms()

        self.neighbors = self.get_neighbors(self.bad_atoms)

        print("Bad atom indices", self.bad_atoms)
        print("Neighbors of bad atoms", self.neighbors)

        # Error checking:
        if self.symbols is None:
            raise ValueError("Symbols improperly initialized")
        if self.coordinates is None:
            raise ValueError("Coordinates improperly initialized")
        if self.species is None:
            raise ValueError("Species improperly initialized")
        if self.structure is None:
            raise ValueError("ASE Structure improperly initialized")
        if self.molecule is None:
            raise ValueError("RDKit Molecule improperly initialized")


        print(Chem.MolToSmiles(self.molecule))
