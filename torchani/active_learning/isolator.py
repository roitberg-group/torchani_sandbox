# type: ignore
import torch
import torchani
from torchani.neighbors import FullPairwise
from torchani.tuples import SpeciesCoordinates
from torchani.utils import PERIODIC_TABLE
from torchani.active_learning.io import read_xyz

import ase
from ase.io import read
import openbabel
from openbabel import pybel
from rdkit import Chem
from rdkit.Chem import AllChem

import numpy as np
from numpy.typing import NDArray
import pandas as pd
import typing as tp
import tempfile
from collections import Counter

class Isolator:
    def __init__(self, model, cutoff: float = 5.2, threshold: float = 1.0):
        # NOTE: Change 'threshold' to 1.0 or higher, 0.5 is just for testing
        self.cutoff = cutoff
        self.threshold = threshold
        
        self.species = None
        self.coordinates = None
        self.structure = None
        self.symbols = None
        
        self.numpy_species = None
        self.numpy_coordinates = None

        self.molecule: tp.Optional[Chem.Mol] = None
        self.model = model

    @classmethod
    def from_file(cls, model, input_file: str):
        instance = cls(model)
        instance.structure = ase.io.read(input_file)
        instance.species = torch.tensor(instance.structure.numbers).unsqueeze(0).clone().detach()
        instance.coordinates = torch.tensor(instance.structure.positions).double().unsqueeze(0).clone().detach()
        instance.symbols = np.asarray(instance.structure.get_chemical_symbols()).astype(str)
        return instance

    @classmethod
    def from_data(cls, model, data: SpeciesCoordinates):
        instances = []
        for species, coordinates in zip(data[0], data[1]):
            instance = cls(model)
            instance.species = data[0]
            instance.coordinates = data[1].double()
            instances.append(instance)
        return instances

    def tensors_to_numpy(self, conformer_idx=None):
        if conformer_idx is None:
            if isinstance(self.species, torch.Tensor):
                self.numpy_species = self.species.cpu().numpy()
            if isinstance(self.coordinates, torch.Tensor):
                self.numpy_coordinates = self.coordinates.detach().cpu().numpy()
        else:
            if isinstance(self.species, torch.Tensor):
                self.numpy_species = self.species[conformer_idx].cpu().numpy()
            if isinstance(self.coordinates, torch.Tensor):
                self.numpy_coordinates = self.coordinates[conformer_idx].detach().cpu().numpy()

    def create_rdkit_mol(self,
        return_smiles: bool = True,
        ) -> Chem.rdchem.Mol:
        """
        This function does the following: 
        * Writes a temp file to read/store xyz information
        * Reads the temp file with openbabel to create a mol2 object (includes connectivity information)
        * Converts the obabel mol2 object into a rdkit.Chem molecule to print the SMILES return the molecule
        """
        with tempfile.NamedTemporaryFile("w+") as f:
            f.write(f"{len(self.symbols)}\n")
            f.write("\n")
            for idx, symbol in enumerate(self.symbols):
                f.write(f"{symbol} {self.numpy_coordinates[idx][0]:8.3} {self.numpy_coordinates[idx][1]:8.3} {self.numpy_coordinates[idx][2]:8.3}\n")
            f.seek(0)
            obabel_molecule = next(pybel.readfile("xyz", f.name))
            raw_mol2 = obabel_molecule.write(format="mol2")
            molecule = Chem.MolFromMol2Block(raw_mol2, removeHs=False)
            if molecule is None:
                print("WARNING: Molecule could not be generated by RDKit for given input.")
                return None
            if return_smiles:
                print("SMILES: ", Chem.MolToSmiles(Chem.RemoveHs(molecule), isomericSmiles=False))
        return molecule

    def classify_bad_atoms(self):
        """
        Classify the 'bad atoms' (based on the uncertainty threshold set in the class initialization)
        """
        force_qbc = self.model.force_qbc((self.species, self.coordinates.requires_grad_(True))).relative_stdev
        if force_qbc.dim() == 1:
            force_qbc = force_qbc.unsqueeze(0)
        bad_atoms_per_conformer = []
        for conformer_uncertainties in force_qbc:
            bad_atom_indices = [i for i, uncertainty in enumerate(conformer_uncertainties) if uncertainty > self.threshold]
            bad_atoms_per_conformer.append(bad_atom_indices)
        return bad_atoms_per_conformer

    def get_neighbors(self, bad_atom_idxs):
        """
        Identify neighbors of bad atoms, within the specified cutoff (defaults to 5.2 Angstrom).
        """
        if isinstance(bad_atom_idxs, int):
            bad_atom_idxs = [bad_atom_idxs]
        if not bad_atom_idxs:
            return {}
        neighbors = FullPairwise(cutoff=self.cutoff)(self.species, self.coordinates.requires_grad_(True))
        neighbor_indices = torch.cat((neighbors.indices, neighbors.indices.flip(0)), dim=-1).transpose(1, 0)
        neighbors_dict = {}

        for atom_index in bad_atom_idxs:
            idxs = neighbor_indices[neighbor_indices[:, 0] == atom_index, 1]
            neighbors_dict[atom_index] = idxs.tolist()
        return neighbors_dict

    def isolate_atoms(self, bad_atom_index):
        """
        Create a unique 'capped' structure for each bad atom, including only the atom and its neighbors.
        """
        bad_atom_neighbors = self.get_neighbors(bad_atom_index)[bad_atom_index]
        #print('Bad atom neighbors:', bad_atom_neighbors)
        involved_atoms = set(bad_atom_neighbors) | {bad_atom_index}

        modified_coords = [self.numpy_coordinates[idx] for idx in involved_atoms]
        modified_symbols = [self.symbols[idx] for idx in involved_atoms]

        return modified_coords, modified_symbols

    def process_bad_atom(self, atom_index):
        """
        Create a new "capped" structure for each high-uncertainty atom present in the input
        """
        capped_coords, capped_symbols = self.isolate_atoms(atom_index)
        return ase.Atoms(positions=capped_coords, symbols=capped_symbols)

    def process_molecule(self, bad_atoms, output_file_prefix="/home/nick/capped_", output_format='xyz'):
        """
        Go through the molecule and create new structures for each of the "bad atoms"
        """
        if not bad_atoms:
            return
        self.structure = ase.Atoms(numbers=self.numpy_species, positions=self.numpy_coordinates)
        self.symbols = np.asarray(self.structure.get_chemical_symbols()).astype(str)

        original_elements = [PERIODIC_TABLE[num] for num in self.numpy_species]
        original_counts = Counter(original_elements)
        original_formula = ''.join(f'{el}{original_counts[el] if original_counts[el] > 1 else ""}' for el in sorted(original_counts))
        counter = 1
        for bad_atom_idx in bad_atoms:
            capped_structure = self.process_bad_atom(bad_atom_idx)
            capped_elements = [PERIODIC_TABLE[num] for num in capped_structure.numbers]
            capped_counts = Counter(capped_elements)

            capped_formula = ''.join(f'{el}{capped_counts[el] if capped_counts[el] > 1 else ""}' for el in sorted(capped_counts))
            output_file = f"{output_file_prefix}{original_formula}_{counter}_{capped_formula}_atom{bad_atom_idx}.{output_format}"
            counter += 1
            ase.io.write(output_file, capped_structure)

    def execute(self, input, is_file=False):
        # Add some more arguments to this function to add the following capabilities:
        #   * output_file_prefix (to overwrite process_molecule, option should be here where we actually run the thing)
        #   * Make input_file able to iterate over a directory of XYZs
        #   * Other stuff? Optional arguments should be added here, because this is where the operations in the class
        #     are actually being executed.
        "Carry out the workflow defined by the functions above"
        if is_file:
            conformers = [self.from_file(input_file=input, model=self.model)]
        else:
            conformers = self.from_data(data=input, model=self.model)
        
        for conformer_idx, conformer in enumerate(conformers):
            self.species = conformer.species
            self.coordinates = conformer.coordinates
            bad_atoms_per_conformer = self.classify_bad_atoms()
            for bad_atoms in bad_atoms_per_conformer:
                if not bad_atoms:
                    print("No atoms exceeding the uncertainty threshold. Skipping to the next structure.")
                    continue
                self.tensors_to_numpy(conformer_idx=conformer_idx)
                self.neighbors = self.get_neighbors(bad_atoms)
                self.process_molecule(bad_atoms)
                self.molecule = self.create_rdkit_mol()
