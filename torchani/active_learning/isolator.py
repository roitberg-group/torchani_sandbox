import torch
import torchani
from torchani.neighbors import FullPairwise
from torchani.tuples import SpeciesCoordinates

import ase
from ase.io import read
import openbabel
from openbabel import pybel
from rdkit import Chem

import numpy as np
from numpy.typing import NDArray
import pandas as pd
import typing as tp
import tempfile
from copy import deepcopy


class Isolator:
    def __init__(self, cutoff: float = 5.2, threshold: float = 0.5):
        # NOTE: Change 'threshold' to 1.0 or higher, 0.5 is just for testing
        self.cutoff = cutoff
        self.threshold = threshold
        
        self.species: tp.Optional[torch.tensor] = None
        self.coordinates = tp.Optional[torch.tensor] = None

        self.structure: tp.Optional[tp.Any] = None

        self.symbols: tp.Optional[np.ndarray] = None
        self.numbers: tp.Optional[np.ndarray] = None
        self.positions: tp.Optional[np.ndarray] = None
        
        self.molecule: tp.Optional[Chem.Mol] = None
        self.model = torchani.models.ANIdr()

    @classmethod
    def from_file(cls, input_file: str):
        obj = cls()
        obj.structure = obj.read_structure(input_file)
        obj.numbers = obj.structure.numbers
        obj.symbols = np.asarray(obj.structure.symbols).astype(str)
        obj.positions = obj.structure.positions.astype(np.float64)
        obj.molecule = obj.create_rdkit_mol((obj.symbols, obj.positions))
        return obj

    @classmethod
    def from_data(cls, data: SpeciesCoordinates):
        obj = cls()
        obj.numbers = data[0].squeeze().cpu().numpy().astype(str)
        obj.positions = data[1].squeeze().detach().cpu().numpy()
        obj.molecule = obj.create_rdkit_mol
        return obj

    def read_structure(self, input_file: tp.Optional[str]) -> ase.Atoms:
        """
        Reads molecular structure rom a file using ase.io, returns ase Atoms object.
          File type is guessed by the ase *filetype* function.
          Works well for .xyz and .pdb, unsure about other file types.
        """
        self.input_file = input_file
        return read(self.input_file)

    @staticmethod
    def create_rdkit_mol(
        data: tp.Union[SpeciesCoordinates, tp.Tuple[NDArray[np.str_], NDArray[np.float64]]],
        verbose: bool = True,
        ) -> Chem.rdchem.Mol:
        """
        This function does the following: 
        * Writes a temp file to read/store xyz information
        * Reads the temp file with openbabel to create a mol2 object (includes connectivity information)
        * Converts the obabel mol2 object into a rdkit.Chem molecule to print the SMILES return the molecule
        """

        if isinstance(data, SpeciesCoordinates):
            symbols = data[0].cpu().numpy().astype(str)
            coordinates = data[1].detach().cpu().numpy()
        else:
            symbols, coordinates = data

        with tempfile.NamedTemporaryFile("w+") as f:
            f.write(f"{len(symbols)}\n")
            f.write("\n")
            for j, el in enumerate(symbols):
                f.write(f"{el} {coordinates[j][0]:8.3} {coordinates[j][1]:8.3} {coordinates[j][2]:8.3}\n")
            f.seek(0)
            obabel_molecule = next(pybel.readfile("xyz", f.name))
            raw_mol2 = obabel_molecule.write(format="mol2")
            molecule = Chem.MolFromMol2Block(raw_mol2, removeHs=False)
            if molecule is None:
                raise RuntimeError("Molecule could not be generated by rdkit")
            if verbose:
                print("SMILES: ", Chem.MolToSmiles(Chem.RemoveHs(molecule), isomericSmiles=False))
        return molecule

    def get_neighbors(self):
        """
        Identify neighbor atoms within the specified cutoff (defaults to 5.2 Angstrom).
        """
        if isinstance(self.numbers, np.ndarray):
            species = torch.tensor(self.numbers).unsqueeze(0)
        elif isinstance(self.species, torch.tensor):
            species = self.species.unsqueeze(0)

        if isinstance(self.positions, np.ndarray):
            coordinates = torch.tensor(self.positions, requires_grad=True).unsqueeze(0)
        else:
            coordinates = self.positions.requires_grad_(True).unsqueeze(0)

        out = FullPairwise(cutoff=self.cutoff)(species, coordinates)

        return torch.cat((out.indices, out.indices.flip(0)), dim=-1).transpose(1, 0)

    def classify_bad_atoms(self):
        """
        Classify the 'bad atoms' (based on the uncertainty threshold set in the class initialization)
        """
        # bad_atom_indices = CALL ANI MODEL HERE -- How to do this with model set as a class init parameter? 

        internal_bad_atom_indices = []
        leaf_bad_atom_indices = []
        atom_list = list(self.molecule.GetAtoms())

        force_qbc = self.model((self.numbers, self.coordinates))                            # NOTE: This doesn't work 

        bad_atom_indices = [1 if i > self.threshold else 0 for i in force_qbc.squeeze()]    # NOTE: This doesn't work either, but this idea needs implementing

        bad_atom_set = set(bad_atom_indices)

        for idx in bad_atom_indices:
            atom = atom_list[idx]
            bonded_atoms = [bond.GetBeginAtomIdx() for bond in atom.GetBonds()]
            if any(atom_idx not in bad_atom_set for atom_idx in bonded_atoms):
                leaf_bad_atom_indices.append(idx)
            else:
                internal_bad_atom_indices.append(idx)

        return internal_bad_atom_indices, leaf_bad_atom_indices

    def cap_atoms(self, bad_atom_indices):
        """
        Cap 'leaf bad atoms' by replacing them with Hydrogen atoms.
        """
        capped_indices = deepcopy(bad_atom_indices)
        _, leaf_bad_atom_indices = self.classify_bad_atoms(bad_atom_indices)

        atom_list = list(self.molecule.GetAtoms())
        bad_atom_set = set(bad_atom_indices)

        for idx in leaf_bad_atom_indices:
            atom = atom_list[idx]
            bonds = atom.GetBonds()
            for bond in bonds:
                begin = bond.GetBeginAtomIdx()
                if begin not in bad_atom_indices:
                    bond_type = bond.GetBondType()
                    if bond_type is not Chem.rdchem.BondType.SINGLE:
                        # NOTE: Placeholder if statement -- must configure for non-single bond types
                        raise NotImplementedError("Not yet implemented.")
                    else:
                        if isinstance(self.symbols, np.ndarray):
                            self.symbols[begin] = "H"
                        elif isinstance(self.symbols, torch.Tensor):    # NOTE: Might need a bit of editing if the tensors aren't nicely organized as GPT suggested they are (i.e., if it is [[1]] rather than [1])
                            self.symbols[begin] = torch.tensor([1], dtype=torch.int)
                        capped_indices.append(begin)
        if isinstance(self.positions, torch.Tensor):
            return self.positions[capped_indices], self.symbols[capped_indices]
        else:
            return self.positions[capped_indices].tolist(), self.symbols[capped_indices].tolist()

    def process_bad_atom(self, atom_index, all_bad_atoms):
        """
        Create a new "capped" structure for each high-uncertainty atom present in the input
        """
        all_neighbors = self.get_neighbors()
        neighbors_of_bad_atoms = set(all_neighbors[atom_index].tolist())
        atoms_to_cap = neighbors_of_bad_atoms - set(all_bad_atoms)
        capped_coords, capped_symbols = self.cap_atoms(atoms_to_cap)
        return ase.Atoms(positions=capped_coords, symbols=capped_symbols)

    def process_molecule(self, bad_atom_indices, output_file_prefix="./capped", output_format='xyz'):
        """
        Go through the molecule and create new structures for each of the "bad atoms"
        """
        # NOTE: Probably update this based on GPT suggestion in "Restructuring and improving ..."
        for idx, bad_atom in enumerate(bad_atom_indices):
            capped_structure = self.process_bad_atom(bad_atom, bad_atom_indices)
            output_file = f"{output_file_prefix}_atom{idx}.{output_format}"
            ase.io.write(output_file, capped_structure)



