import torch
import torchani
from torchani.neighbors import FullPairwise
from torchani.tuples import SpeciesCoordinates
from torchani.utils import PERIODIC_TABLE
from torchani.active_learning.io import read_xyz

import ase
from ase.io import read
import openbabel
from openbabel import pybel
from rdkit import Chem
from rdkit.Chem import AllChem

import numpy as np
from numpy.typing import NDArray
import pandas as pd
import typing as tp
import tempfile
from collections import Counter

class Isolator:
    def __init__(self, model, cutoff: float = 5.2, threshold: float = 1.0):
        # NOTE: Change 'threshold' to 1.0 or higher, 0.5 is just for testing
        self.cutoff = cutoff
        self.threshold = threshold
        
        self.species = None
        self.coordinates = None
        self.structure = None
        self.symbols = None
        
        self.numpy_species = None
        self.numpy_coordinates = None

        self.molecule: tp.Optional[Chem.Mol] = None
        self.model = model

    @classmethod
    def from_file(cls, model, input_file: str):
        instance = cls(model)
        instance.structure = ase.io.read(input_file)
        instance.species = torch.tensor(instance.structure.numbers).unsqueeze(0).clone().detach()
        instance.coordinates = torch.tensor(instance.structure.positions).double().unsqueeze(0).clone().detach()
        instance.symbols = np.asarray(instance.structure.get_chemical_symbols()).astype(str)
        return instance

    @classmethod
    def from_data(cls, model, data: SpeciesCoordinates):
        instances = []
        for species, coordinates in zip(data[0], data[1]):
            instance = cls(model)
            instance.species = data[0]
            instance.coordinates = data[1].double()
            instances.append(instance)
        return instances

    def tensors_to_numpy(self):
        if isinstance(self.species, torch.Tensor):
            self.numpy_species = self.species.squeeze().cpu().numpy()
        if isinstance(self.coordinates, torch.Tensor):
            self.numpy_coordinates = self.coordinates.squeeze().detach().cpu().numpy()

    def create_rdkit_mol(self,
        return_smiles: bool = True,
        ) -> Chem.rdchem.Mol:
        """
        This function does the following: 
        * Writes a temp file to read/store xyz information
        * Reads the temp file with openbabel to create a mol2 object (includes connectivity information)
        * Converts the obabel mol2 object into a rdkit.Chem molecule to print the SMILES return the molecule
        """
        if self.numpy_coordinates is None:
            self.tensors_to_numpy()

        with tempfile.NamedTemporaryFile("w+") as f:
            f.write(f"{len(self.symbols)}\n")
            f.write("\n")
            for idx, symbol in enumerate(self.symbols):
                f.write(f"{symbol} {self.numpy_coordinates[idx][0]:8.3} {self.numpy_coordinates[idx][1]:8.3} {self.numpy_coordinates[idx][2]:8.3}\n")
            f.seek(0)
            obabel_molecule = next(pybel.readfile("xyz", f.name))
            raw_mol2 = obabel_molecule.write(format="mol2")
            molecule = Chem.MolFromMol2Block(raw_mol2, removeHs=False)
            if molecule is None:
                print("WARNING: Molecule could not be generated by RDKit for given input.")
                return None
            if return_smiles:
                print("SMILES: ", Chem.MolToSmiles(Chem.RemoveHs(molecule), isomericSmiles=False))
        return molecule

    def classify_bad_atoms(self):
        """
        Classify the 'bad atoms' (based on the uncertainty threshold set in the class initialization)
        """
        species_tensor = self.species
        coord_tensor = self.coordinates.requires_grad_(True)
        force_qbc = self.model.force_qbc((species_tensor, coord_tensor)).relative_stdev
        bad_atom_indices = [i for i, x in enumerate(force_qbc.squeeze()) if x > self.threshold]
        return bad_atom_indices

    def get_neighbors(self, bad_atom_indices):
        """
        Identify neighbors of bad atoms, within the specified cutoff (defaults to 5.2 Angstrom).
        """
        if not any(bad_atom_indices):
            return {}
        species_tensor = self.species
        coord_tensor = self.coordinates.requires_grad_(True)
        neighbors = FullPairwise(cutoff=self.cutoff)(
            species_tensor,
            coord_tensor
            )
        neighbor_indices = torch.cat((neighbors.indices, neighbors.indices.flip(0)), dim=-1).transpose(1, 0)
        neighbors_dict = {}

        for atom_index in bad_atom_indices:
            idxs = neighbor_indices[neighbor_indices[:, 0] == atom_index, 1]
            neighbors_dict[atom_index] = idxs.tolist()
        return neighbors_dict

    def isolate_atoms(self, bad_atom_index, all_bad_atoms):
        """
        Create a unique 'capped' structure for each bad atom, including only the atom and its neighbors.
        """
        bad_atom_neighbors = self.get_neighbors([bad_atom_index])[bad_atom_index]
        #print('Bad atom neighbors:', bad_atom_neighbors)
        involved_atoms = set(bad_atom_neighbors) | {bad_atom_index}

        modified_coords = [self.numpy_coordinates[idx] for idx in involved_atoms]
        modified_symbols = [self.symbols[idx] for idx in involved_atoms]

        return modified_coords, modified_symbols

    def process_bad_atom(self, atom_index, all_bad_atoms):
        """
        Create a new "capped" structure for each high-uncertainty atom present in the input
        """
        if self.numpy_coordinates is None:
            self.tensors_to_numpy()

        if self.structure is None:
            self.structure = ase.Atoms(numbers=self.numpy_species, positions=self.numpy_coordinates)
            self.symbols = np.asarray(self.structure.get_chemical_symbols()).astype(str)


        capped_coords, capped_symbols = self.isolate_atoms(atom_index, all_bad_atoms)
        return ase.Atoms(positions=capped_coords, symbols=capped_symbols)

    def process_molecule(self, bad_atom_indices, output_file_prefix="/home/nick/capped_", output_format='xyz'):
        """
        Go through the molecule and create new structures for each of the "bad atoms"
        """
        species_numpy = self.species.squeeze().numpy() if isinstance(self.species, torch.Tensor) else self.species
        original_elements = [PERIODIC_TABLE[num] for num in species_numpy]
        original_counts = Counter(original_elements)
        original_formula = ''.join(f'{el}{original_counts[el] if original_counts[el] > 1 else ""}' for el in sorted(original_counts))
        counter = 1
        for idx in bad_atom_indices:
            capped_structure = self.process_bad_atom(idx, bad_atom_indices)
            capped_elements = [PERIODIC_TABLE[num] for num in capped_structure.numbers]
            capped_counts = Counter(capped_elements)
            capped_formula = ''.join(f'{el}{capped_counts[el] if capped_counts[el] > 1 else ""}' for el in sorted(capped_counts))
            output_file = f"{output_file_prefix}{original_formula}_{counter}_{capped_formula}_atom{idx}.{output_format}"
            counter += 1
            ase.io.write(output_file, capped_structure)

    def execute(self, input, is_file=False):
        "Carry out the workflow defined by the functions above"
        if is_file:
            instances = [self.from_file(input_file=input, model=self.model)]
        else:
            instances = self.from_data(data=input, model=self.model)
        
        for instance in instances:
            self.symbols = instance.symbols
            self.coordinates = instance.coordinates
            self.species = instance.species
            self.structure = instance.structure
            self.bad_atoms = self.classify_bad_atoms()
            if not self.bad_atoms:
                print("No atoms exceeding the uncertainty threshold. Skipping to the next structure.")
                return
            self.neighbors = self.get_neighbors(self.bad_atoms)
            self.process_molecule(self.bad_atoms)
            self.molecule = self.create_rdkit_mol()
