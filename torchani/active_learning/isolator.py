import torch
import torchani
from torchani.neighbors import FullPairwise
from torchani.tuples import SpeciesCoordinates
from torchani.utils import PERIODIC_TABLE
from torchani.AL_protocol.io import read_xyz

import ase
from ase.io import read
import openbabel
from openbabel import pybel
from rdkit import Chem
from rdkit.Chem import AllChem

import numpy as np
from numpy.typing import NDArray
import pandas as pd
import typing as tp
import tempfile
from collections import Counter

class Isolator:
    def __init__(self, model, cutoff: float = 5.2, threshold: float = 1.0):
        # NOTE: Change 'threshold' to 1.0 or higher, 0.5 is just for testing
        self.cutoff = cutoff
        self.threshold = threshold
        
        self.species = None
        self.coordinates = None
        self.structure = None
        self.symbols = None
        
        self.molecule: tp.Optional[Chem.Mol] = None
        self.model = model

    def read_structure(self, input_file: tp.Optional[str]) -> ase.Atoms:
        """
        Reads molecular structure rom a file using ase.io, returns ase Atoms object.
          File type is guessed by the ase *filetype* function.
          Works well for .xyz and .pdb, unsure about other file types.
        """
        return read(input_file)

    @classmethod
    def from_file(cls, model, input_file: str):
        instance = cls(model)
        instance.structure = instance.read_structure(input_file)
        instance.species = instance.structure.numbers
        instance.coordinates = instance.structure.positions.astype(np.float64)
        instance.symbols = np.asarray(instance.structure.get_chemical_symbols()).astype(str)
        return instance

    @classmethod
    def from_data(cls, model, data: SpeciesCoordinates):
        instance = cls(model)
        instance.species = data[0].squeeze().cpu().numpy()
        instance.coordinates = data[1].squeeze().detach().cpu().numpy()
        instance.structure = ase.Atoms(numbers=instance.species, positions=instance.coordinates)
        instance.symbols = np.asarray(instance.structure.get_chemical_symbols()).astype(str)
        return instance

    def create_rdkit_mol(self,
        return_smiles: bool = True,
        ) -> Chem.rdchem.Mol:
        """
        This function does the following: 
        * Writes a temp file to read/store xyz information
        * Reads the temp file with openbabel to create a mol2 object (includes connectivity information)
        * Converts the obabel mol2 object into a rdkit.Chem molecule to print the SMILES return the molecule
        """
        with tempfile.NamedTemporaryFile("w+") as f:
            f.write(f"{len(self.symbols)}\n")
            f.write("\n")
            for idx, symbol in enumerate(self.symbols):
                f.write(f"{symbol} {self.coordinates[idx][0]:8.3} {self.coordinates[idx][1]:8.3} {self.coordinates[idx][2]:8.3}\n")
            f.seek(0)
            obabel_molecule = next(pybel.readfile("xyz", f.name))
            raw_mol2 = obabel_molecule.write(format="mol2")
            molecule = Chem.MolFromMol2Block(raw_mol2, removeHs=False)
            if molecule is None:
                print("WARNING: Molecule could not be generated by RDKit for given input.")
                return None
            if return_smiles:
                print("SMILES: ", Chem.MolToSmiles(Chem.RemoveHs(molecule), isomericSmiles=False))
        return molecule

    def classify_bad_atoms(self):
        """
        Classify the 'bad atoms' (based on the uncertainty threshold set in the class initialization)
        """
        force_qbc = self.model.force_qbc(
            (
            torch.tensor(self.species).unsqueeze(0), 
            torch.tensor(self.coordinates).unsqueeze(0).double()
            )).relative_stdev
        bad_atom_indices = [i for i, x in enumerate(force_qbc.squeeze()) if x > self.threshold]
        return bad_atom_indices

    def get_neighbors(self, bad_atom_indices):
        """
        Identify neighbors of bad atoms, within the specified cutoff (defaults to 5.2 Angstrom).
        """
        if not any(bad_atom_indices):
            return {}

        species_tensor = torch.tensor(self.species).unsqueeze(0)
        coord_tensor = torch.tensor(self.coordinates, requires_grad=True).unsqueeze(0)

        neighbors = FullPairwise(cutoff=self.cutoff)(
            species_tensor,
            coord_tensor
            )
        neighbor_indices = torch.cat((neighbors.indices, neighbors.indices.flip(0)), dim=-1).transpose(1, 0)
        neighbors_dict = {}

        for atom_index in bad_atom_indices:
            idxs = neighbor_indices[neighbor_indices[:, 0] == atom_index, 1]
            neighbors_dict[atom_index] = idxs.tolist()
        return neighbors_dict

    def isolate_atoms(self, bad_atom_index, all_bad_atoms):
        """
        Create a unique 'capped' structure for each bad atom, including only the atom and its neighbors.
        """
        bad_atom_neighbors = self.get_neighbors([bad_atom_index])[bad_atom_index]
        involved_atoms = set(bad_atom_neighbors) | {bad_atom_index}

        modified_coords = [self.coordinates[idx] for idx in involved_atoms]
        modified_symbols = [self.symbols[idx] for idx in involved_atoms]

        return modified_coords, modified_symbols

    def process_bad_atom(self, atom_index, all_bad_atoms):
        """
        Create a new "capped" structure for each high-uncertainty atom present in the input
        """
        capped_coords, capped_symbols = self.isolate_atoms(atom_index, all_bad_atoms)
        return ase.Atoms(positions=capped_coords, symbols=capped_symbols)

    def process_molecule(self, bad_atom_indices, output_file_prefix="/home/nick/capped_", output_format='xyz'):
        """
        Go through the molecule and create new structures for each of the "bad atoms"
        """
        original_elements = [PERIODIC_TABLE[num] for num in self.species]
        original_counts = Counter(original_elements)
        original_formula = ''.join(f'{el}{original_counts[el] if original_counts[el] > 1 else ""}' for el in sorted(original_counts))
        counter = 1
        for idx in bad_atom_indices:
            capped_structure = self.process_bad_atom(idx, bad_atom_indices)
            capped_elements = [PERIODIC_TABLE[num] for num in capped_structure.numbers]
            capped_counts = Counter(capped_elements)
            capped_formula = ''.join(f'{el}{capped_counts[el] if capped_counts[el] > 1 else ""}' for el in sorted(capped_counts))
            output_file = f"{output_file_prefix}{original_formula}_{counter}_{capped_formula}_atom{idx}.{output_format}"
            counter += 1
            ase.io.write(output_file, capped_structure)

    def execute(self, input, is_file=False):
        if is_file:
            instance = self.from_file(input_file=input, model=self.model)
        else:
            instance = self.from_data(data=input, model=self.model)
        
        self.symbols = instance.symbols
        self.coordinates = instance.coordinates
        self.species = instance.species
        self.structure = instance.structure
        self.bad_atoms = self.classify_bad_atoms()
        if not self.bad_atoms:
            print("No atoms exceeding the uncertainty threshold. Skipping to the next structure.")
            return
        self.neighbors = self.get_neighbors(self.bad_atoms)
        self.process_molecule(self.bad_atoms)
        self.molecule = self.create_rdkit_mol()
