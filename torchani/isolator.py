import torch
from torchani.neighbors import FullPairwise
import ase
import openbabel
from openbabel import pybel
from rdkit import Chem

import numpy as np
from numpy.typing import NDArray
import pandas as pd
import typing as tp
import tempfile
from copy import deepcopy                   # NOTE: Needed?


class Isolator:
    def __init__(self, input_file: str, cutoff: float = 5.2, threshold: float = 0.5):
        # NOTE: Change 'threshold' to 1.0 or higher, 0.5 is just for testing
        self.input_file = input_file
        self.cutoff = cutoff
        self.structure = self.read_structure()
        self.numbers = self.structure.numbers
        self.symbols = np.asarray(self.structure.symbols).astype(str)
        self.positions = self.structure.positions.astype(np.float64)
        self.molecule = self.np_arrays_to_rdkit_mol(self.numbers, self.positions)

    def read_structure(self):
        """
        Reads molecular structure rom a file using ase.io, returns ase Atoms object.
          File type is guessed by the ase *filetype* function.
          Works well for .xyz and .pdb, unsure about other file types.
        """
        return ase.io.read(self.input_file)
    
    @staticmethod
    def np_arrays_to_rdkit_mol(
        symbols: NDArray[np.str_],
        coordinates: NDArray[np.float64],
        verbose: bool = True,
        ) -> Chem.rdchem.Mol:
        """
        This function does the following: 
        * Writes a temp file to read/store xyz information
        * Reads the temp file with openbabel to create a mol2 object (includes connectivity information)
        * Converts the obabel mol2 object into a rdkit.Chem molecule to print the SMILES return the molecule
        """
        with tempfile.NamedTemporaryFile("w+") as f:
            f.write(f"{len(symbols)}\n")
            f.write("\n")
            for j, el in enumerate(symbols):
                f.write(f"{el} {coordinates[j][0]:8.3} {coordinates[j][1]:8.3} {coordinates[j][2]:8.3}\n")
            f.seek(0)
            obabel_molecule = next(pybel.readfile("xyz", f.name))
            raw_mol2 = obabel_molecule.write(format="mol2")
            molecule = Chem.MolFromMol2Block(raw_mol2, removeHs=False)
            if molecule is None:
                raise RuntimeError("Molecule could not be generated by rdkit")
            if verbose:
                print("SMILES: ", Chem.MolToSmiles(Chem.RemoveHs(molecule), isomericSmiles=False))
        return molecule

    def get_neighbors(self, numbers, positions):
        """
        Identify neighbor atoms within the specified cutoff (defaults to 5.2 Angstrom).
        """
        species = torch.tensor(self.numbers).unsqueeze(0)
        coordinates = torch.tensor(self.positions, requires_grad=True).unsqueeze(0)
        out = FullPairwise(cutoff=self.cutoff)(species, coordinates)
        return torch.cat((out.indices, out.indices.flip(0)), dim=-1).transpose(1, 0)
    
    def classify_bad_atoms(self, bad_atom_indices):
        """
        Classify the 'bad atoms' (based on the uncertainty threshold set in the class initialization)
        """
        internal_bad_atom_indices = []
        leaf_bad_atom_indices = []
        atom_list = list(self.molecule.GetAtoms())
        for idx in bad_atom_indices:
            atom = atom_list[idx]
            bonds = atom.GetBonds()
            for bond in bonds:
                begin = bond.GetBeginAtomIdx()
                if begin not in bad_atom_indices:
                    leaf_bad_atom_indices.append(idx)
                    break
            else:
                internal_bad_atom_indices.append(idx)
        return internal_bad_atom_indices, leaf_bad_atom_indices

    def cap_atoms(self, bad_atom_indices):
        """
        Cap 'leaf bad atoms' by replacing them with Hydrogen atoms.
        """
        capped_indices = deepcopy(bad_atom_indices)
        _, leaf_bad_atom_indices = self.classify_bad_atoms(bad_atom_indices)
        atom_list = list(self.molecule.GetAtoms())
        for idx in leaf_bad_atom_indices:
            atom = atom_list[idx]
            bonds = atom.GetBonds()
            for bond in bonds:
                begin = bond.GetBeginAtomIdx()
                if begin not in bad_atom_indices:
                    bond_type = bond.GetBondType()
                    if bond_type is not Chem.rdchem.BondType.SINGLE:
                        # NOTE: Placeholder if statement -- must configure for non-single bond types
                        raise NotImplementedError("Not yet implemented.")
                    else:
                        self.symbols[begin] = "H"
                        capped_indices.append(begin)
        return self.positions[capped_indices], self.symbols[capped_indices]

    def process_bad_atom(self, atom_index, all_bad_atoms):
        """
        Create a new "capped" structure for each high-uncertainty atom present in the input
        """
        all_neighbors = self.get_neighbors(self.numbers, self.positions)
        neighbors_of_bad_atoms = set(all_neighbors[atom_index].tolist())
        atoms_to_cap = neighbors_of_bad_atoms - set(all_bad_atoms)
        capped_coords, capped_symbols = self.cap_atoms(atoms_to_cap)
        return ase.Atoms(positions=capped_coords, symbols=capped_symbols)

    def process_molecule(self, bad_atom_indices, output_file_prefix="./capped"):
        for idx, bad_atom in enumerate(bad_atom_indices):
            capped_structure = self.process_bad_atom(bad_atom, bad_atom_indices)
            output_file = f"{output_file_prefix}_atom{idx}.xyz"
            ase.io.write(output_file, capped_structure)



